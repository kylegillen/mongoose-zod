'use client'
import{z as Te}from"zod";import{z as A}from"zod";import{z as ge}from"zod";var F=Symbol.for("MongooseTypeOptions"),S=Symbol.for("MongooseSchemaOptions"),m=class extends A.ZodType{_parse(t){return A.OK(t.data)}static create(t){return new m(t)}},ee=function(e,t={}){return m.create({mongoose:t,innerType:e})},j=e=>{e===null?A.ZodObject.prototype.mongoose!==void 0&&delete A.ZodObject.prototype.mongoose:e.ZodObject.prototype.mongoose===void 0&&(e.ZodObject.prototype.mongoose=function(t={}){return ee(this,t)})},oe=function(e,t){return e._def[F]={...e._def[F],...t},e},U=e=>{e===null?A.ZodType.prototype.mongooseTypeOptions!==void 0&&delete A.ZodType.prototype.mongooseTypeOptions:e.ZodType.prototype.mongooseTypeOptions===void 0&&(e.ZodType.prototype.mongooseTypeOptions=function(t){return oe(this,t)})};var f=class extends Error{};import P from"mongoose";import{z as ne}from"zod";var te=()=>ne.date().default(new Date),Se=(e="createdAt",t="updatedAt")=>{if(e!=null&&t!=null&&e===t)throw new f("`createdAt` and `updatedAt` fields must be different");let n=ne.object({...e!=null&&{[e]:te().mongooseTypeOptions({immutable:!0,index:!0})},...t!=null&&{[t]:te().mongooseTypeOptions({index:!0})}});return n._def[S]={...n._def[S],timestamps:{createdAt:e??!1,updatedAt:t??!1}},n},L=e=>e,z=class extends P.SchemaTypes.Boolean{constructor(){super(...arguments);this.cast=L}};z.schemaName="MongooseZodBoolean";var D=class extends P.SchemaTypes.Date{constructor(){super(...arguments);this.cast=L}};D.schemaName="MongooseZodDate";var M=class extends P.SchemaTypes.Number{constructor(){super(...arguments);this.cast=L}};M.schemaName="MongooseZodNumber";var h=class extends P.SchemaTypes.String{constructor(){super(...arguments);this.cast=L}};h.schemaName="MongooseZodString";var se=()=>{Object.assign(P.Schema.Types,{MongooseZodBoolean:z,MongooseZodDate:D,MongooseZodNumber:M,MongooseZodString:h})},B=e=>e instanceof P.mongo.Binary?e.buffer:e;import H,{Schema as ce}from"mongoose";import ze from"zod";import{z as ae}from"zod";var E={isSetUp:!1},Me=(e={})=>{E.isSetUp||(E.isSetUp=!0,E.options=e,j(null),U(null),e.z!==null&&(j(e.z||ae),U(e.z||ae)))};import{createRequire as Oe}from"node:module";var re=e=>{let t=Object.keys(e).filter(d=>typeof e[e[d]]!="number"),n={};for(let d of t)n[d]=e[d];return Object.values(n)},R=(e,t)=>{let n=Oe(t.url);try{let d=n.resolve(e);return{module:n(d)}}catch{return null}};import ie from"mongoose";import{z as be}from"zod";var s=(e,t)=>e.constructor.name===t,T=(e,t={},n={})=>{let d=e._def[F];n.mongooseTypeOptions||(n.mongooseTypeOptions=d);let l=e._def[S];if(n.mongooseSchemaOptions||(n.mongooseSchemaOptions=l),s(e,"ZodUnion")){let y=e._def.options.map(w=>w.constructor.name);new Set(y).size===1&&(n.unionSchemaType??(n.unionSchemaType=y[0]))}if(e instanceof m)return T(e._def.innerType,t,{...n,mongoose:e._def.mongoose});if(s(e,"ZodObject")){let y=e._def.unknownKeys;if(y==="strict"||y==="passthrough")return T(e.strip(),t,{...n,unknownKeys:y})}if(s(e,"ZodOptional"))return T(e.unwrap(),t,{...n,isOptional:!0});if(s(e,"ZodDefault"))return T(e._def.innerType,t,"default"in n?n:{...n,default:e._def.defaultValue()});if(s(e,"ZodBranded")||s(e,"ZodNullable"))return T(e.unwrap(),t,{...n});if(s(e,"ZodEffects")&&e._def.effect.type==="refinement")return T(e._def.schema,t,n);if(s(e,"ZodArray")&&!t.doNotUnwrapArrays){let y=Number(n.array?.wrapInArrayTimes||0)+1;return T(e._def.type,t,{...n,array:{...n.array,wrapInArrayTimes:y,originalArraySchema:n.array?.originalArraySchema||e}})}return{schema:e,features:n}},q=new WeakMap,xe=(e,t)=>{let n=e==="Buffer"?Buffer:ie.Types[e],d=ie.Schema.Types[e],l=be.instanceof(n,t);return q.set(l._def.schema,d),l};var{Mixed:I}=H.Schema.Types,we=H.Query.prototype.lean;se();var de=R("mongoose-lean-virtuals",import.meta),pe=R("mongoose-lean-defaults",import.meta),ye=R("mongoose-lean-getters",import.meta),C=e=>function(...t){let n=this&&this instanceof H.Document?this:void 0;return e.apply(n,t)},ue=(e,t)=>{let n=e==null||e==="throw"||t.unknownKeys==="strict",d=e==="strip-unless-overridden"&&t.unknownKeys==="passthrough";return n?"throw":!d},me=(e,t,n)=>{let{fieldsStack:d=[],monSchemaOptions:l,monTypeOptions:y,unknownKeys:w}=n,k=d.at(-1),v=d.join("."),O=k==null,b=(o,r)=>{throw new f(`${r?"":`Path \`${v}\`: `}${o}`)},{schema:a,features:p}=T(e),Z=p.mongoose||{},{mongooseTypeOptions:fe,mongooseSchemaOptions:he,unionSchemaType:K}=p,g={...fe,...y},G=!p.isOptional&&!s(a,"ZodNull"),_="array"in p,J=[["validate",g.mzValidate],["required",g.mzRequired]];J.forEach(([o])=>{let r=`mz${o[0]?.toUpperCase()}${o.slice(1)}`;r in g&&(o in g&&b(`Can't have both "${r}" and "${o}" set`),g[o]=g[r],delete g[r])});let c={required:G,..."default"in p?{default:p.default}:_||s(a,"ZodObject")?{default:void 0}:{},..._&&{castNonArrays:!1},...g},[[,W],[,Y]]=J;if(W!=null){let o=W;if(typeof o=="function")o=C(o);else if(!Array.isArray(o)&&typeof o=="object"&&!(o instanceof RegExp))o.validator=C(o.validator);else if(Array.isArray(o)&&!(o[0]instanceof RegExp&&typeof o[1]=="string")){let[r,u]=o;typeof r=="function"&&typeof u=="string"&&(c.mzValidate=[C(r),u])}c.validate=o}if(Y!=null){let o=Y;if(typeof o=="function")o=C(o);else if(Array.isArray(o)&&typeof o[0]=="function"){let[r]=o;typeof r=="function"&&(o[0]=C(r))}c.required=o}G?c.required!==!0&&b("Can't have `required` set to anything but true if `.optional()` not used"):c.required===!0&&b("Can't have `required` set to true and `.optional()` used");let i,x="",Q=(O?l?.typeKey:n.typeKey)??"type";if(s(a,"ZodObject")){let o=O?t:new ce({},{strict:ue(w,p),...he,typeKey:Q,...Z?.schemaOptions});for(let[r,u]of Object.entries(a._def.shape()))me(u,o,{...n,fieldsStack:[...d,r],monTypeOptions:Z.typeOptions?.[r],typeKey:Z?.schemaOptions?.typeKey??Q});if(O)return;"_id"in c||(c._id=!1),i=o}else if(s(a,"ZodNumber")||K==="ZodNumber")i=M;else if(s(a,"ZodString")||K==="ZodString")i=h;else if(s(a,"ZodDate")||K==="ZodDate")i=D;else if(s(a,"ZodBoolean")||K==="ZodBoolean")i=z;else if(s(a,"ZodLiteral")){let o=a._def.value;switch(typeof o){case"boolean":{i=z;break}case"number":{i=Number.isNaN(o)?I:Number.isFinite(o)?M:void 0;break}case"string":{i=h;break}case"object":{o||(i=I),x="object literals are not supported";break}default:x="only boolean, number, string or null literals are supported"}}else if(s(a,"ZodEnum")){let o=a._def.values;Array.isArray(o)&&o.length>0&&o.every(r=>typeof r=="string")?i=h:x="only nonempty zod enums with string values are supported"}else if(s(a,"ZodNativeEnum")){let o=re(a._def.values),r=[...new Set(o.map(u=>typeof u))];r.length===1&&r[0]==="number"?i=M:r.length===1&&r[0]==="string"?i=h:r.length===2&&["string","number"].every(u=>r.includes(u))?i=I:x="only nonempty native enums with number and strings values are supported"}else if(s(e,"ZodNaN")||s(e,"ZodNull"))i=I;else if(s(a,"ZodMap"))i=Map;else if(s(a,"ZodAny")){let o=q.get(a);i=o||I,o===H.Schema.Types.Buffer&&!("get"in c)&&(c.get=B)}else s(a,"ZodEffects")?a._def.effect.type!=="refinement"&&(x="only refinements are supported"):(s(a,"ZodUnknown")||s(a,"ZodRecord")||s(a,"ZodUnion")||s(a,"ZodTuple")||s(a,"ZodDiscriminatedUnion")||s(a,"ZodIntersection")||s(a,"ZodTypeAny")||s(a,"ZodType"))&&(i=I);if(O)throw new f("You must provide object schema at root level");if(i==null){let o=a.constructor.name;b(`${o} type is not supported${x?` (${x})`:""}`)}if(p.array)for(let o=0;o<p.array.wrapInArrayTimes;o++)i=[i];t.add({[k]:{...c,[Q]:i}}),t.paths[k]?.validate(function(o){let r=p.array?.originalArraySchema||a;s(r,"ZodObject")&&(r=ze.preprocess(V=>{if(!V||typeof V!="object")return V;let N=V;for(let[Ze,X]of Object.entries(N))X instanceof H.mongo.Binary&&(N===V&&(N={...V}),N[Ze]=X.buffer);return N},r));let u=o&&typeof o=="object"&&"toObject"in o&&typeof o.toObject=="function"?o.toObject():o;return r.parse(u),!0})},$=(e,t)=>t!=null&&(t===!0||t[e]),le={leanDefaults:!0,leanGetters:!0,leanVirtuals:!0},Ve=(e,t={})=>{if(!(e instanceof m))throw new f("Root schema must be an instance of ZodMongoose");let n=E.options?.defaultToMongooseSchemaOptions||{},d={...n,...t,disablePlugins:{...n.disablePlugins===!0?{...le}:n.disablePlugins,...t.disablePlugins===!0?{...le}:t.disablePlugins}},{disablePlugins:l,unknownKeys:y}=d,w=e._def,k=w.innerType._def?.[S],v=w?.mongoose.schemaOptions,O=de&&!$("leanVirtuals",l),b=pe&&!$("leanDefaults",l),a=ye&&!$("leanGetters",l),p=new ce({},{id:!1,minimize:!1,strict:ue(y,T(e).features),...k,...v,query:{lean(Z){return we.call(this,typeof Z=="object"||Z==null?{...O&&{virtuals:!0},...b&&{defaults:!0},...a&&{getters:!0},versionKey:!1,...Z}:Z)},...v?.query}});return me(e,p,{monSchemaOptions:v,unknownKeys:y}),O&&p.plugin(de.module),b&&p.plugin(pe.module?.default),a&&p.plugin(ye.module),p};j(Te);U(Te);export{S as MongooseSchemaOptionsSymbol,F as MongooseTypeOptionsSymbol,f as MongooseZodError,m as ZodMongoose,oe as addMongooseTypeOptions,B as bufferMongooseGetter,Se as genTimestampsSchema,xe as mongooseZodCustomType,Me as setup,Ve as toMongooseSchema,ee as toZodMongooseSchema,ge as z};
