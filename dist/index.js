"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }'use client'
var _zod = require('zod'); var _zod2 = _interopRequireDefault(_zod);var F=Symbol.for("MongooseTypeOptions"),S= exports.MongooseSchemaOptionsSymbol =Symbol.for("MongooseSchemaOptions"),m= exports.ZodMongoose =class extends _zod.z.ZodType{_parse(t){return _zod.z.OK(t.data)}static create(t){return new m(t)}},ee= exports.toZodMongooseSchema =function(e,t={}){return m.create({mongoose:t,innerType:e})},j=e=>{e===null?_zod.z.ZodObject.prototype.mongoose!==void 0&&delete _zod.z.ZodObject.prototype.mongoose:e.ZodObject.prototype.mongoose===void 0&&(e.ZodObject.prototype.mongoose=function(t={}){return ee(this,t)})},oe= exports.addMongooseTypeOptions =function(e,t){return e._def[F]={...e._def[F],...t},e},U=e=>{e===null?_zod.z.ZodType.prototype.mongooseTypeOptions!==void 0&&delete _zod.z.ZodType.prototype.mongooseTypeOptions:e.ZodType.prototype.mongooseTypeOptions===void 0&&(e.ZodType.prototype.mongooseTypeOptions=function(t){return oe(this,t)})};var f=class extends Error{};var _mongoose = require('mongoose'); var _mongoose2 = _interopRequireDefault(_mongoose);var te=()=>_zod.z.date().default(new Date),Se= exports.genTimestampsSchema =(e="createdAt",t="updatedAt")=>{if(e!=null&&t!=null&&e===t)throw new f("`createdAt` and `updatedAt` fields must be different");let n=_zod.z.object({...e!=null&&{[e]:te().mongooseTypeOptions({immutable:!0,index:!0})},...t!=null&&{[t]:te().mongooseTypeOptions({index:!0})}});return n._def[S]={...n._def[S],timestamps:{createdAt:_nullishCoalesce(e, () => (!1)),updatedAt:_nullishCoalesce(t, () => (!1))}},n},L=e=>e,z=class extends _mongoose2.default.SchemaTypes.Boolean{constructor(){super(...arguments);this.cast=L}};z.schemaName="MongooseZodBoolean";var D=class extends _mongoose2.default.SchemaTypes.Date{constructor(){super(...arguments);this.cast=L}};D.schemaName="MongooseZodDate";var M=class extends _mongoose2.default.SchemaTypes.Number{constructor(){super(...arguments);this.cast=L}};M.schemaName="MongooseZodNumber";var h=class extends _mongoose2.default.SchemaTypes.String{constructor(){super(...arguments);this.cast=L}};h.schemaName="MongooseZodString";var se=()=>{Object.assign(_mongoose2.default.Schema.Types,{MongooseZodBoolean:z,MongooseZodDate:D,MongooseZodNumber:M,MongooseZodString:h})},B= exports.bufferMongooseGetter =e=>e instanceof _mongoose2.default.mongo.Binary?e.buffer:e;var E={isSetUp:!1},Me= exports.setup =(e={})=>{E.isSetUp||(E.isSetUp=!0,E.options=e,j(null),U(null),e.z!==null&&(j(e.z||_zod.z),U(e.z||_zod.z)))};var _module = require('module');var re=e=>{let t=Object.keys(e).filter(d=>typeof e[e[d]]!="number"),n={};for(let d of t)n[d]=e[d];return Object.values(n)},R=(e,t)=>{let n=_module.createRequire.call(void 0, t.url);try{let d=n.resolve(e);return{module:n(d)}}catch (e2){return null}};var s=(e,t)=>e.constructor.name===t,T=(e,t={},n={})=>{let d=e._def[F];n.mongooseTypeOptions||(n.mongooseTypeOptions=d);let l=e._def[S];if(n.mongooseSchemaOptions||(n.mongooseSchemaOptions=l),s(e,"ZodUnion")){let y=e._def.options.map(w=>w.constructor.name);new Set(y).size===1&&(_nullishCoalesce(n.unionSchemaType, () => ((n.unionSchemaType=y[0]))))}if(e instanceof m)return T(e._def.innerType,t,{...n,mongoose:e._def.mongoose});if(s(e,"ZodObject")){let y=e._def.unknownKeys;if(y==="strict"||y==="passthrough")return T(e.strip(),t,{...n,unknownKeys:y})}if(s(e,"ZodOptional"))return T(e.unwrap(),t,{...n,isOptional:!0});if(s(e,"ZodDefault"))return T(e._def.innerType,t,"default"in n?n:{...n,default:e._def.defaultValue()});if(s(e,"ZodBranded")||s(e,"ZodNullable"))return T(e.unwrap(),t,{...n});if(s(e,"ZodEffects")&&e._def.effect.type==="refinement")return T(e._def.schema,t,n);if(s(e,"ZodArray")&&!t.doNotUnwrapArrays){let y=Number(_optionalChain([n, 'access', _2 => _2.array, 'optionalAccess', _3 => _3.wrapInArrayTimes])||0)+1;return T(e._def.type,t,{...n,array:{...n.array,wrapInArrayTimes:y,originalArraySchema:_optionalChain([n, 'access', _4 => _4.array, 'optionalAccess', _5 => _5.originalArraySchema])||e}})}return{schema:e,features:n}},q=new WeakMap,xe= exports.mongooseZodCustomType =(e,t)=>{let n=e==="Buffer"?Buffer:_mongoose2.default.Types[e],d=_mongoose2.default.Schema.Types[e],l=_zod.z.instanceof(n,t);return q.set(l._def.schema,d),l};var{Mixed:I}=_mongoose2.default.Schema.Types,we=_mongoose2.default.Query.prototype.lean;se();var de=R("mongoose-lean-virtuals",import.meta),pe=R("mongoose-lean-defaults",import.meta),ye=R("mongoose-lean-getters",import.meta),C=e=>function(...t){let n=this&&this instanceof _mongoose2.default.Document?this:void 0;return e.apply(n,t)},ue=(e,t)=>{let n=e==null||e==="throw"||t.unknownKeys==="strict",d=e==="strip-unless-overridden"&&t.unknownKeys==="passthrough";return n?"throw":!d},me=(e,t,n)=>{let{fieldsStack:d=[],monSchemaOptions:l,monTypeOptions:y,unknownKeys:w}=n,k=d.at(-1),v=d.join("."),O=k==null,b=(o,r)=>{throw new f(`${r?"":`Path \`${v}\`: `}${o}`)},{schema:a,features:p}=T(e),Z=p.mongoose||{},{mongooseTypeOptions:fe,mongooseSchemaOptions:he,unionSchemaType:K}=p,g={...fe,...y},G=!p.isOptional&&!s(a,"ZodNull"),_="array"in p,J=[["validate",g.mzValidate],["required",g.mzRequired]];J.forEach(([o])=>{let r=`mz${_optionalChain([o, 'access', _6 => _6[0], 'optionalAccess', _7 => _7.toUpperCase, 'call', _8 => _8()])}${o.slice(1)}`;r in g&&(o in g&&b(`Can't have both "${r}" and "${o}" set`),g[o]=g[r],delete g[r])});let c={required:G,..."default"in p?{default:p.default}:_||s(a,"ZodObject")?{default:void 0}:{},..._&&{castNonArrays:!1},...g},[[,W],[,Y]]=J;if(W!=null){let o=W;if(typeof o=="function")o=C(o);else if(!Array.isArray(o)&&typeof o=="object"&&!(o instanceof RegExp))o.validator=C(o.validator);else if(Array.isArray(o)&&!(o[0]instanceof RegExp&&typeof o[1]=="string")){let[r,u]=o;typeof r=="function"&&typeof u=="string"&&(c.mzValidate=[C(r),u])}c.validate=o}if(Y!=null){let o=Y;if(typeof o=="function")o=C(o);else if(Array.isArray(o)&&typeof o[0]=="function"){let[r]=o;typeof r=="function"&&(o[0]=C(r))}c.required=o}G?c.required!==!0&&b("Can't have `required` set to anything but true if `.optional()` not used"):c.required===!0&&b("Can't have `required` set to true and `.optional()` used");let i,x="",Q=_nullishCoalesce((O?_optionalChain([l, 'optionalAccess', _9 => _9.typeKey]):n.typeKey), () => ("type"));if(s(a,"ZodObject")){let o=O?t:new (0, _mongoose.Schema)({},{strict:ue(w,p),...he,typeKey:Q,..._optionalChain([Z, 'optionalAccess', _10 => _10.schemaOptions])});for(let[r,u]of Object.entries(a._def.shape()))me(u,o,{...n,fieldsStack:[...d,r],monTypeOptions:_optionalChain([Z, 'access', _11 => _11.typeOptions, 'optionalAccess', _12 => _12[r]]),typeKey:_nullishCoalesce(_optionalChain([Z, 'optionalAccess', _13 => _13.schemaOptions, 'optionalAccess', _14 => _14.typeKey]), () => (Q))});if(O)return;"_id"in c||(c._id=!1),i=o}else if(s(a,"ZodNumber")||K==="ZodNumber")i=M;else if(s(a,"ZodString")||K==="ZodString")i=h;else if(s(a,"ZodDate")||K==="ZodDate")i=D;else if(s(a,"ZodBoolean")||K==="ZodBoolean")i=z;else if(s(a,"ZodLiteral")){let o=a._def.value;switch(typeof o){case"boolean":{i=z;break}case"number":{i=Number.isNaN(o)?I:Number.isFinite(o)?M:void 0;break}case"string":{i=h;break}case"object":{o||(i=I),x="object literals are not supported";break}default:x="only boolean, number, string or null literals are supported"}}else if(s(a,"ZodEnum")){let o=a._def.values;Array.isArray(o)&&o.length>0&&o.every(r=>typeof r=="string")?i=h:x="only nonempty zod enums with string values are supported"}else if(s(a,"ZodNativeEnum")){let o=re(a._def.values),r=[...new Set(o.map(u=>typeof u))];r.length===1&&r[0]==="number"?i=M:r.length===1&&r[0]==="string"?i=h:r.length===2&&["string","number"].every(u=>r.includes(u))?i=I:x="only nonempty native enums with number and strings values are supported"}else if(s(e,"ZodNaN")||s(e,"ZodNull"))i=I;else if(s(a,"ZodMap"))i=Map;else if(s(a,"ZodAny")){let o=q.get(a);i=o||I,o===_mongoose2.default.Schema.Types.Buffer&&!("get"in c)&&(c.get=B)}else s(a,"ZodEffects")?a._def.effect.type!=="refinement"&&(x="only refinements are supported"):(s(a,"ZodUnknown")||s(a,"ZodRecord")||s(a,"ZodUnion")||s(a,"ZodTuple")||s(a,"ZodDiscriminatedUnion")||s(a,"ZodIntersection")||s(a,"ZodTypeAny")||s(a,"ZodType"))&&(i=I);if(O)throw new f("You must provide object schema at root level");if(i==null){let o=a.constructor.name;b(`${o} type is not supported${x?` (${x})`:""}`)}if(p.array)for(let o=0;o<p.array.wrapInArrayTimes;o++)i=[i];t.add({[k]:{...c,[Q]:i}}),_optionalChain([t, 'access', _15 => _15.paths, 'access', _16 => _16[k], 'optionalAccess', _17 => _17.validate, 'call', _18 => _18(function(o){let r=_optionalChain([p, 'access', _19 => _19.array, 'optionalAccess', _20 => _20.originalArraySchema])||a;s(r,"ZodObject")&&(r=_zod2.default.preprocess(V=>{if(!V||typeof V!="object")return V;let N=V;for(let[Ze,X]of Object.entries(N))X instanceof _mongoose2.default.mongo.Binary&&(N===V&&(N={...V}),N[Ze]=X.buffer);return N},r));let u=o&&typeof o=="object"&&"toObject"in o&&typeof o.toObject=="function"?o.toObject():o;return r.parse(u),!0})])},$=(e,t)=>t!=null&&(t===!0||t[e]),le={leanDefaults:!0,leanGetters:!0,leanVirtuals:!0},Ve= exports.toMongooseSchema =(e,t={})=>{if(!(e instanceof m))throw new f("Root schema must be an instance of ZodMongoose");let n=_optionalChain([E, 'access', _21 => _21.options, 'optionalAccess', _22 => _22.defaultToMongooseSchemaOptions])||{},d={...n,...t,disablePlugins:{...n.disablePlugins===!0?{...le}:n.disablePlugins,...t.disablePlugins===!0?{...le}:t.disablePlugins}},{disablePlugins:l,unknownKeys:y}=d,w=e._def,k=_optionalChain([w, 'access', _23 => _23.innerType, 'access', _24 => _24._def, 'optionalAccess', _25 => _25[S]]),v=_optionalChain([w, 'optionalAccess', _26 => _26.mongoose, 'access', _27 => _27.schemaOptions]),O=de&&!$("leanVirtuals",l),b=pe&&!$("leanDefaults",l),a=ye&&!$("leanGetters",l),p=new (0, _mongoose.Schema)({},{id:!1,minimize:!1,strict:ue(y,T(e).features),...k,...v,query:{lean(Z){return we.call(this,typeof Z=="object"||Z==null?{...O&&{virtuals:!0},...b&&{defaults:!0},...a&&{getters:!0},versionKey:!1,...Z}:Z)},..._optionalChain([v, 'optionalAccess', _28 => _28.query])}});return me(e,p,{monSchemaOptions:v,unknownKeys:y}),O&&p.plugin(de.module),b&&p.plugin(_optionalChain([pe, 'access', _29 => _29.module, 'optionalAccess', _30 => _30.default])),a&&p.plugin(ye.module),p};j(_zod.z);U(_zod.z);exports.MongooseSchemaOptionsSymbol = S; exports.MongooseTypeOptionsSymbol = F; exports.MongooseZodError = f; exports.ZodMongoose = m; exports.addMongooseTypeOptions = oe; exports.bufferMongooseGetter = B; exports.genTimestampsSchema = Se; exports.mongooseZodCustomType = xe; exports.setup = Me; exports.toMongooseSchema = Ve; exports.toZodMongooseSchema = ee; exports.z = _zod.z;
